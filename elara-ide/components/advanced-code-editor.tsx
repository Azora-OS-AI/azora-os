/*
AZORA PROPRIETARY LICENSE

Copyright © 2025 Azora ES (Pty) Ltd. All Rights Reserved.

See LICENSE file for details.
*/

'use client';

import type { Monaco } from '@monaco-editor/react';
import Editor from '@monaco-editor/react';
import {
  Brain,
  FileCode,
  Play,
  Save,
  Search,
  Sparkles, Wand2,
  Zap
} from 'lucide-react';
import type { editor } from 'monaco-editor';
import { useCallback, useEffect, useRef, useState } from 'react';

interface AdvancedCodeEditorProps {
  activeFile: string | null;
  fileContent?: string;
  onSave?: (content: string) => void;
  onAIRequest?: (request: string, context: string) => Promise<string>;
}

export function AdvancedCodeEditor({
  activeFile,
  fileContent,
  onSave,
  onAIRequest
}: AdvancedCodeEditorProps) {
  const [code, setCode] = useState(fileContent || '');

  // Update code when fileContent prop changes
  useEffect(() => {
    if (fileContent !== undefined) {
      setCode(fileContent);
    }
  }, [fileContent]);
  const [isSaving, setIsSaving] = useState(false);
  const [aiSuggestions, setAiSuggestions] = useState<string[]>([]);
  const [showAICompletions, setShowAICompletions] = useState(false);
  const [editorTheme, setEditorTheme] = useState('vs-dark');
  const editorRef = useRef<editor.IStandaloneCodeEditor | null>(null);
  const monacoRef = useRef<Monaco | null>(null);

  // Initialize Monaco Editor
  const handleEditorDidMount = (
    editor: editor.IStandaloneCodeEditor,
    monaco: Monaco
  ) => {
    editorRef.current = editor;
    monacoRef.current = monaco;

    // Configure AI-powered autocomplete
    setupAIAutocomplete(monaco, editor);

    // Add custom keybindings
    setupKeybindings(editor);

    // Setup AI inline suggestions
    setupInlineSuggestions(editor);
  };

  // Setup AI-powered autocomplete
  const setupAIAutocomplete = (
    monaco: Monaco,
    editor: editor.IStandaloneCodeEditor
  ) => {
    // Register AI completion provider
    monaco.languages.registerCompletionItemProvider('typescript', {
      provideCompletionItems: async (model, position) => {
        const word = model.getWordUntilPosition(position);
        const range = {
          startLineNumber: position.lineNumber,
          endLineNumber: position.lineNumber,
          startColumn: word.startColumn,
          endColumn: word.endColumn,
        };

        // Get context for AI
        const context = model.getValue();
        const beforeCursor = context.substring(0, model.getOffsetAt(position));

        // Simulate AI suggestions (replace with actual Elara API call)
        const suggestions = await getAICompletions(beforeCursor);

        return {
          suggestions: suggestions.map((suggestion, index) => ({
            label: `✨ ${suggestion.substring(0, 50)}...`,
            kind: monaco.languages.CompletionItemKind.Function,
            insertText: suggestion,
            range,
            detail: 'AI Suggestion',
            documentation: 'Generated by Elara AI',
            sortText: `0${index}`,
          })),
        };
      },
      triggerCharacters: ['.', '(', '[', '{', ' ', ':', '='],
    });

    // Setup for JavaScript, Python, etc.
    ['javascript', 'python', 'json', 'html', 'css'].forEach((lang) => {
      monaco.languages.registerCompletionItemProvider(lang, {
        provideCompletionItems: async (model, position) => {
          const word = model.getWordUntilPosition(position);
          const range = {
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn,
          };

          const context = model.getValue();
          const beforeCursor = context.substring(0, model.getOffsetAt(position));
          const suggestions = await getAICompletions(beforeCursor);

          return {
            suggestions: suggestions.map((suggestion, index) => ({
              label: `✨ ${suggestion.substring(0, 50)}...`,
              kind: monaco.languages.CompletionItemKind.Text,
              insertText: suggestion,
              range,
              detail: 'AI Suggestion',
            })),
          };
        },
      });
    });
  };

  // Setup inline AI suggestions (like GitHub Copilot)
  const setupInlineSuggestions = (editor: editor.IStandaloneCodeEditor) => {
    let decorationId: string[] = [];

    editor.onDidChangeCursorPosition(async () => {
      const model = editor.getModel();
      if (!model) return;

      const position = editor.getPosition();
      if (!position) return;

      const line = model.getLineContent(position.lineNumber);
      const beforeCursor = line.substring(0, position.column - 1);

      // Get AI inline suggestion
      if (beforeCursor.length > 10) {
        const suggestion = await getInlineSuggestion(model.getValue(), position);

        if (suggestion) {
          // Clear previous decorations
          decorationId = editor.deltaDecorations(decorationId, []);

          // Add suggestion decoration
          decorationId = editor.deltaDecorations(decorationId, [
            {
              range: new monacoRef.current!.Range(
                position.lineNumber,
                position.column,
                position.lineNumber,
                position.column + suggestion.length
              ),
              options: {
                after: {
                  content: suggestion,
                  inlineClassName: 'ai-inline-suggestion',
                  inlineClassNameAffectsLetterSpacing: true,
                },
                hoverMessage: { value: 'Press Tab to accept AI suggestion' },
              },
            },
          ]);
        }
      }
    });
  };

  // Setup custom keybindings
  const setupKeybindings = (editor: editor.IStandaloneCodeEditor) => {
    // Ctrl+K for AI command palette
    editor.addCommand(monacoRef.current!.KeyMod.CtrlCmd | monacoRef.current!.KeyCode.KeyK, () => {
      openAICommandPalette();
    });

    // Ctrl+L for AI chat
    editor.addCommand(monacoRef.current!.KeyMod.CtrlCmd | monacoRef.current!.KeyCode.KeyL, () => {
      openAIChat();
    });

    // Alt+Enter for accept AI suggestion
    editor.addCommand(monacoRef.current!.KeyMod.Alt | monacoRef.current!.KeyCode.Enter, () => {
      acceptAISuggestion();
    });

    // Ctrl+Shift+A for AI refactor
    editor.addCommand(
      monacoRef.current!.KeyMod.CtrlCmd | monacoRef.current!.KeyMod.Shift | monacoRef.current!.KeyCode.KeyA,
      () => {
        openAIRefactor();
      }
    );
  };

  // Get AI completions
  const getAICompletions = async (context: string): Promise<string[]> => {
    // Use onAIRequest callback if provided, otherwise return empty
    if (onAIRequest) {
      try {
        const response = await onAIRequest('complete', context);
        return [response]; // Parse response into suggestions
      } catch (error) {
        console.error('AI completion error:', error);
      }
    }
    // Return basic TypeScript completions as fallback
    return [];
  };

  // Get inline suggestion
  const getInlineSuggestion = async (
    fullCode: string,
    position: any
  ): Promise<string | null> => {
    // TODO: Implement with Elara API
    return null;
  };

  const handleSave = useCallback(async () => {
    if (!editorRef.current) return;

    setIsSaving(true);
    const content = editorRef.current.getValue();

    try {
      if (onSave) {
        await onSave(content);
      }
      // Show success indicator
      setTimeout(() => setIsSaving(false), 1000);
    } catch (error) {
      setIsSaving(false);
      console.error('Save error:', error);
    }
  }, [onSave]);

  const openAICommandPalette = () => {
    // TODO: Implement command palette
    console.log('Opening AI command palette');
  };

  const openAIChat = () => {
    // TODO: Open AI chat panel
    console.log('Opening AI chat');
  };

  const acceptAISuggestion = () => {
    // TODO: Accept inline suggestion
    console.log('Accepting AI suggestion');
  };

  const openAIRefactor = () => {
    // TODO: Open AI refactor dialog
    console.log('Opening AI refactor');
  };

  const handleCodeChange = (value: string | undefined) => {
    if (value !== undefined) {
      setCode(value);
    }
  };

  return (
    <div className="flex-1 flex flex-col bg-background">
      {/* Enhanced Editor Header */}
      <div className="h-12 bg-card border-b border-border flex items-center justify-between px-4">
        <div className="flex items-center space-x-3">
          <FileCode className="w-4 h-4 text-muted-foreground" />
          <span className="text-sm font-medium">
            {activeFile || 'untitled.ts'}
          </span>
          {isSaving && (
            <span className="text-xs text-muted-foreground">Saving...</span>
          )}
        </div>

        <div className="flex items-center space-x-2">
          {/* AI Actions */}
          <button
            onClick={() => setShowAICompletions(!showAICompletions)}
            className="p-2 hover:bg-accent rounded relative group"
            title="AI Completions (Ctrl+K)"
          >
            <Sparkles className="w-4 h-4 text-primary" />
            {showAICompletions && (
              <div className="absolute top-full right-0 mt-1 bg-popover border border-border rounded-lg shadow-lg p-2 w-64 z-50">
                <div className="text-xs text-muted-foreground mb-2">AI Suggestions</div>
                {aiSuggestions.length > 0 ? (
                  aiSuggestions.map((suggestion, idx) => (
                    <div
                      key={idx}
                      className="text-xs p-2 hover:bg-accent rounded cursor-pointer"
                    >
                      {suggestion.substring(0, 60)}...
                    </div>
                  ))
                ) : (
                  <div className="text-xs text-muted-foreground">
                    Start typing to get AI suggestions
                  </div>
                )}
              </div>
            )}
          </button>

          <button
            onClick={openAIRefactor}
            className="p-2 hover:bg-accent rounded"
            title="AI Refactor (Ctrl+Shift+A)"
          >
            <Wand2 className="w-4 h-4" />
          </button>

          <button
            onClick={openAIChat}
            className="p-2 hover:bg-accent rounded"
            title="AI Chat (Ctrl+L)"
          >
            <Brain className="w-4 h-4" />
          </button>

          <div className="w-px h-6 bg-border mx-1" />

          {/* Standard Actions */}
          <button
            onClick={handleSave}
            className="p-2 hover:bg-accent rounded"
            title="Save (Ctrl+S)"
          >
            <Save className="w-4 h-4" />
          </button>
          <button className="p-2 hover:bg-accent rounded" title="Run">
            <Play className="w-4 h-4" />
          </button>
          <button className="p-2 hover:bg-accent rounded" title="Search">
            <Search className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* Monaco Editor */}
      <div className="flex-1 relative">
        <Editor
          height="100%"
          defaultLanguage="typescript"
          language={activeFile?.split('.').pop() || 'typescript'}
          theme={editorTheme}
          value={code}
          onChange={handleCodeChange}
          onMount={handleEditorDidMount}
          options={{
            fontSize: 14,
            minimap: { enabled: true },
            wordWrap: 'on',
            automaticLayout: true,
            tabSize: 2,
            suggestOnTriggerCharacters: true,
            quickSuggestions: true,
            quickSuggestionsDelay: 100,
            acceptSuggestionOnCommitCharacter: true,
            acceptSuggestionOnEnter: 'on',
            snippetSuggestions: 'top',
            inlineSuggest: { enabled: true },
            parameterHints: { enabled: true },
            formatOnPaste: true,
            formatOnType: true,
            bracketPairColorization: { enabled: true },
            guides: {
              bracketPairs: true,
              indentation: true,
            },
            cursorBlinking: 'smooth',
            cursorSmoothCaretAnimation: 'on',
            smoothScrolling: true,
            fontFamily: "'Fira Code', 'JetBrains Mono', 'Courier New', monospace",
            fontLigatures: true,
          }}
        />
      </div>

      {/* Enhanced Status Bar */}
      <div className="h-8 bg-card border-t border-border flex items-center justify-between px-4 text-xs text-muted-foreground">
        <div className="flex items-center space-x-4">
          <span>{activeFile?.split('.').pop()?.toUpperCase() || 'TS'}</span>
          <span>UTF-8</span>
          <span>LF</span>
          <span>Spaces: 2</span>
        </div>
        <div className="flex items-center space-x-4">
          {editorRef.current && (
            <>
              <span>
                Ln {editorRef.current.getPosition()?.lineNumber || 1}, Col{' '}
                {editorRef.current.getPosition()?.column || 1}
              </span>
              <span>
                {code.split('\n').length} lines
              </span>
            </>
          )}
          <button className="hover:text-foreground">
            <Zap className="w-3 h-3" />
          </button>
        </div>
      </div>

      <style jsx global>{`
        .ai-inline-suggestion {
          color: rgba(139, 139, 139, 0.5);
          font-style: italic;
        }
      `}</style>
    </div>
  );
}

